/** 
*
* FILTER.js Image Processing Filter Library for JavaScript and HTML5 canvas
* http://github.com/foo123/FILTER.js
*
* @version 0.3
*
* @author Nikos M. http://nikos-web-development-netai.net
*
**/
/** 
*
* FILTER.js Image Processing Filter Library for JavaScript and HTML5 canvas
* http://github.com/foo123/FILTER.js
*
* @version 0.3
*
* @author Nikos M. http://nikos-web-development-netai.net
*
**/
var FILTER=FILTER || {};
/**
*
* Image Canvas Class
* @package FILTER.js
*
* NOTE: it won't work locally (at least with Firefox), only with server
**/
(function(FILTER){
    
    var 
        blendModes,
        Min=Math.min
    ;
    
    /**
     * JavaScript implementation of common blending modes, based on
     * http://stackoverflow.com/questions/5919663/how-does-photoshop-blend-two-images-together
     **/
    blendModes = {
        normal: function(a, b) { return a; },

        lighten: function(a, b) { return (b > a) ? b : a; },

        darken: function(a, b) { return (b > a) ? a : b; },

        multiply: function(a, b) { return (a * b * 0.003921568627451); },

        average: function(a, b) { return 0.5*(a + b); },

        add: function(a, b) { return Math.min(255, a + b); },

        substract: function(a, b) {  return (a + b < 255) ? 0 : a + b - 255; },

        difference: function(a, b) { return Math.abs(a - b); },

        negation: function(a, b) { return 255 - Math.abs(255 - a - b); },

        screen: function(a, b) { return 255 - (((255 - a) * (255 - b)) >> 8); },

        exclusion: function(a, b) { return a + b - 2 * a * b * 0.003921568627451; },

        overlay: function(a, b) { return b < 128 ? (2 * a * b * 0.003921568627451) : (255 - 2 * (255 - a) * (255 - b) * 0.003921568627451); },

        softLight: function(a, b) { return b < 128 ? (2 * ((a >> 1) + 64)) * (b * 0.003921568627451) : 255 - (2 * (255 - (( a >> 1) + 64)) * (255 - b) * 0.003921568627451); },

        // reverse of overlay
        hardLight: function(b, a) { return b < 128 ? (2 * a * b * 0.003921568627451) : (255 - 2 * (255 - a) * (255 - b) * 0.003921568627451); },

        colorDodge: function(a, b) { return b == 255 ? b : Math.min(255, ((a << 8 ) / (255 - b))); },

        colorBurn: function(a, b) { return b == 0 ? b : Math.max(0, (255 - ((255 - a) << 8 ) / b)); },

        //linearDodge: blendModes.add,

        //linearBurn: blendModes.substract,

        linearLight: function(a, b) { return b < 128 ? blendModes.linearBurn(a, 2 * b) : blendModes.linearDodge(a, (2 * (b - 128))); },

        vividLight: function(a, b) { return b < 128 ? blendModes.colorBurn(a, 2 * b) : blendModes.colorDodge(a, (2 * (b - 128))); },

        pinLight: function(a, b) { return b < 128 ? blendModes.darken(a, 2 * b) : blendModes.lighten(a, (2 * (b - 128))); },

        hardMix: function(a, b) { return blendModes.vividLight(a, b) < 128 ? 0 : 255; },

        reflect: function(a, b) { return b == 255 ? b : Math.min(255, (a * a / (255 - b))); },

        // reverse of reflect
        glow: function(b, a) { return b == 255 ? b : Math.min(255, (a * a / (255 - b))); },

        phoenix: function(a, b) { return Math.min(a, b) - Math.max(a, b) + 255; }
    };
    blendModes.linearDodge= blendModes.add;
    blendModes.linearBurn= blendModes.substract;
    
    FILTER.blendModes=blendModes;
    
    //
    //
    // Image Class
    FILTER.Image=function(img, callback)
    {
        this.width=0;
        this.height=0;
        this.type='undefined';
        this.image=null;
        this.canvasElement=null;
        this.context=null;
        this.imageData=null;
        this._histogram=null;
        this._integral=null;
        this.canvasElement=document.createElement('canvas');
        this.canvasElement.width=0;
        this.canvasElement.height=0;
        this.context=this.canvasElement.getContext('2d');
        this._histogramRefresh=true;
        this._integralRefresh=true;
        this.setImage(img,callback);
    };
    
    FILTER.Image.prototype={
    
        blend : function(image, mode, amount, startX, startY) {
            if (typeof mode == 'undefined') mode='normal';
            if (typeof amount == 'undefined') amount=1;
            if (amount>1) amount=1;
            if (amount<0) amount=0;
            if (typeof startX == 'undefined')  startX=0;
            if (typeof startY == 'undefined')  startY=0;
            
            var sx=0,sy=0;
            
            if (startX<0)
            {
                sx=-startX;
                startX=0;
            }
            if (startY<0)
            {
                sy=-startY;
                startY=0;
            }
            if (startX>=this.width || startY>=this.height)
            {
                return;
            }
            
            var blendingMode = blendModes[mode];
            if (blendingMode==undefined || blendingMode==null) return this;
            
            var 
                width = Min(this.width, image.width-sx), height = Min(this.height, image.height-sy),
                imageData1 = this.context.getImageData(startX,startY,width,height),
                imageData2 = image.context.getImageData(sx, sy, width, height),
                /** @type Array */
                pixels1 = imageData1.data,
                /** @type Array */
                pixels2 = imageData2.data,
                r, g, b, oR, oG, oB, invamount = 1 - amount,
                len=pixels2.length, i
            ;

            
            
            // blend images
            for (i = 0; i < len; i += 4) {
                oR = pixels1[i];
                oG = pixels1[i + 1];
                oB = pixels1[i + 2];

                // calculate blended color
                r = blendingMode(pixels2[i], oR);
                g = blendingMode(pixels2[i + 1], oG);
                b = blendingMode(pixels2[i + 2], oB);

                // amount compositing
                pixels1[i] =     r * amount + oR * invamount;
                pixels1[i + 1] = g * amount + oG * invamount;
                pixels1[i + 2] = b * amount + oB * invamount;
            }
            this.context.putImageData(imageData1, startX, startY);
            this._histogramRefresh=true;
            this._integralRefresh=true;
            return this;
        },
        
        clone : function(withimage) {
            if (typeof withimage == 'undefined') withimage=false;
            if (withimage && this.image && this.image.src)  return new FILTER.Image(this.image.src);
            else  return new FILTER.Image(this.canvasElement);
        },
        
        integral : function(doGray) {
            if (this._integralRefresh) this._computeIntegral(doGray);
            return this._integral;
        },
        
        // compute integral image (sum of columns)
        _computeIntegral : function(doGray) 
        {
            var w=this.width,h=this.height, count=w*h, integral = new FILTER.Array32U(count),
                im=this.getPixelData().data, i, j, k, col, pix, gray
            ;
            // use one while loop instead of 2 for loops (arguably faster)
            i=0; j=0; k=0; col=0;
            while (i<w)
            {
                ii=i+k;  pix=ii << 2;
                gray = ((4899 * im[pix] + 9617 * im[pix + 1] + 1868 * im[pix + 2]) + 8192) >>> 14;
                col += (gray&0xFF) >>> 0;
                if (i>0) integral[ii] = integral[ii-1] + col;
                else  integral[ii] = col;
                j++; k+=w;
                if (h==j) { i++; j=0; k=0; col=0; }
            }
            this._integral=integral;
            this._integralRefresh=false;
        },
        
        histogram : function() {
            if (this._histogramRefresh) this._computeHistogram();
            return this._histogram;
        },
        
        _computeHistogram : function() {
            var im=this.getPixelData().data, i=0, l=im.length,
                _histogramR=new FILTER.ImArray(256), 
                _histogramG=new FILTER.ImArray(256), 
                _histogramB=new FILTER.ImArray(256),
                r,g,b
            ;
            i=0; while (i<256) { _histogramR[i]=0; _histogramG[i]=0; _histogramB[i]=0; i++; }
            i=0;
            while (i<l)
            {
                r=im[i]; g=im[i+1]; b=im[i+2];
                _histogramR[r]++;
                _histogramG[g]++;
                _histogramB[b]++;
                i+=4;
            }
            this._histogram=[_histogramR, _histogramG, _histogramB];
            this._histogramRefresh=false;
        },
        
        createImageData : function(w,h) {
            this.width=w;
            this.height=h;
            this.canvasElement.width=this.width;
            this.canvasElement.height=this.height;
            this.context=this.canvasElement.getContext('2d');
            this.context.createImageData(w,h);
            this.imageData=this.context.getImageData(0,0,this.width,this.height);
            return this.imageData;
        },
        
        getData : function() {
            // clone it
            return new FILTER.ImArray(this.imageData.data);
        },
        
        setData : function(a) {
            this.imageData.data.set(a);
            this.context.putImageData(this.imageData, 0, 0); 
            this._histogramRefresh=true;
            this._integralRefresh=true;
            return this;
        },
        
        getPixelData : function() {
            return this.imageData;
        },
        
        setPixelData : function(data) {
            this.context.putImageData(data,0,0); 
            this.imageData=this.context.getImageData(0,0,this.width,this.height);
            this._histogramRefresh=true;
            this._integralRefresh=true;
            return this;
        },
        
        setWidth : function(w) {
            this.width=w;
            this.canvasElement.width=this.width;
            this.context=this.canvasElement.getContext('2d');
            this.imageData=this.context.getImageData(0,0,this.width,this.height);
            this._histogramRefresh=true;
            this._integralRefresh=true;
            return this;
        },
        
        setHeight : function(h) {
            this.height=h;
            this.canvasElement.height=this.height;
            this.context=this.canvasElement.getContext('2d');
            this.imageData=this.context.getImageData(0,0,this.width,this.height);
            this._histogramRefresh=true;
            this._integralRefresh=true;
            return this;
        },
        
        setImage : function(img,callback) {
            if (typeof img=='undefined' || img==null) return;
            var thiss=this;
            if (img instanceof Image || img instanceof HTMLCanvasElement || img instanceof HTMLVideoElement)
            {
                this.image=img;
                this.width=img.width;
                this.height=img.height;
                //this.canvasElement=document.createElement('canvas');
                this.canvasElement.width=this.width;
                this.canvasElement.height=this.height;
                this.context=this.canvasElement.getContext('2d');
                this.context.drawImage(this.image,0,0);
                this.imageData=this.context.getImageData(0,0,this.width,this.height);
                if (img instanceof Image) this.type='image';
                if (img instanceof HTMLCanvasElement)  this.type='canvas';
                if (img instanceof HTMLVideoElement) this.type='video';
                this._histogramRefresh=true;
                this._integralRefresh=true;
            }
            else // url string
            {
                this.image=new Image();
                //this.canvasElement=document.createElement('canvas');
                this.type='image-url';
                this.image.onload=function(){
                    thiss.width=thiss.image.width;
                    thiss.height=thiss.image.height;
                    //thiss.canvasElement=document.createElement('canvas');
                    thiss.canvasElement.width=thiss.width;
                    thiss.canvasElement.height=thiss.height;
                    thiss.context=thiss.canvasElement.getContext('2d');
                    thiss.context.drawImage(thiss.image,0,0);
                    thiss.imageData=thiss.context.getImageData(0,0,thiss.width,thiss.height);
                    if (typeof callback != 'undefined') callback.call(thiss);
                    thiss._histogramRefresh=true;
                    thiss._integralRefresh=true;
                };
                this.image.src=img; // load it
            }
            this.image.crossOrigin = '';
            return this;
        }
    };
    
})(FILTER);/**
*
* Color Transforma
* @package FILTER.js
*
**/
(function(FILTER){

    // static color transform methods
    FILTER.Color={
        
		blend : function(rgb1, rgb2, p) {
            return {
                red: rgb1.red - ~~((rgb1.red - rgb2.red) * p + 0.5), 
                green:rgb1.green - ~~((rgb1.green - rgb2.green) * p + 0.5), 
                blue: rgb1.blue - ~~((rgb1.blue - rgb2.blue) * p + 0.5)
            };
        },
        
        distance : function(rgb1, rgb2) {
            var dr=rgb1.red-rgb2.red, dg=rgb1.green-rgb2.green, db=rgb1.blue-rgb2.blue;
            return Math.sqrt(dr*dr + dg*dg + db*db);
        },
        
        RGBA2Color : function(rgb) {
            return (typeof rgb.alpha !='undefined') ? 
                ((rgb.alpha << 24) + (rgb.red << 16) + (rgb.green << 8) + rgb.blue) : 
                ((rgb.red << 16) + (rgb.green << 8) + rgb.blue);
        },
        
        Color2RGBA : function(c) {
            c=~~c;
            return {
                red : (c >> 16) & 255,
                green : (c >> 8) & 255,
                blue : (c & 255),
                alpha : (c >> 24) & 255
            };
        },

        RGB2YCbCr : function(rgb) {
			var y, cb, cr, r=rgb.red, g=rgb.green, b=rgb.blue;
			
			y=~~(0.299*r +0.587*g +0.114*b);
			cb=~~(128-0.169*r -0.331*g +0.500*b);
			cr=~~(128 +0.500*r -0.42*g -0.080*b);
			return {Y:y, Cb:cb, Cr:cr};
		},
        
        YCbCr2RGB : function(ycbcr) {
            var r, g, b, y=ycbcr.Y, cb=ycbcr.Cb, cr=ycbcr.Cr;
			
            r=~~(y + 1.4(cr-128));
			g=~~(y-0.343*(cb-128)-0.711*(cr-128));
			b=~~(y+1.765*(cb-128));
			return {red:r, green:g, blue:b};
        },
        
        RGB2HSV :function(rgb) {
            var rr=rgb.red*0.0039215686274509803921568627451, // / 255
                gg=rgb.green*0.0039215686274509803921568627451,  // / 255
                bb=rgb.blue*0.0039215686274509803921568627451, // / 255
                H, S, V, t1, t2, t3
            ;
            t1= rr < gg ? (rr < bb ? (rr) : (bb)) : (gg < bb ? (gg) : (bb));
            V = rr > gg ? (rr > bb ? (rr) : (bb)) : (gg > bb ? (gg) : (bb));
            if (t1 == V)
            {
                return {H:NaN, S:0, V:V};
            }
            t2 = rr == t1 ? (gg - bb) : (gg == t1 ? (bb - rr) : (rr - gg));
            t3 = rr == t1 ? (3) : (gg == t1 ? (5) : (1));
            H = ((rr == t1 ? (3) : (gg == t1 ? (5) : (1))) - t2 / (V - t1)) * 60;
            if (H >= 360)
            {
                H -= 360;
            }
            else if (H < 0)
            {
                H += 360;
            }
            $ = (V - t1) / V;
            return {H:H, S:S, V:V};
        }
    };
    
})(FILTER);/**
*
* Filter SuperClass
* @package FILTER.js
*
**/
(function(FILTER){

    // typed arrays substitute 
    FILTER.Array32F = (typeof Float32Array !== "undefined") ? Float32Array : Array;
    FILTER.Array64F = (typeof Float64Array !== "undefined") ? Float64Array : Array;
    FILTER.Array8I = (typeof Int8Array !== "undefined") ? Int8Array : Array;
    FILTER.Array16I = (typeof Int16Array !== "undefined") ? Int16Array : Array;
    FILTER.Array32I = (typeof Int32Array !== "undefined") ? Int32Array : Array;
    FILTER.Array8U = (typeof Uint8Array !== "undefined") ? Uint8Array : Array;
    FILTER.Array16U = (typeof Uint16Array !== "undefined") ? Uint16Array : Array;
    FILTER.Array32U = (typeof Uint32Array !== "undefined") ? Uint32Array : Array;
    FILTER.ImArray = (typeof Uint8ClampedArray !== "undefined") ? Uint8ClampedArray : FILTER.Array8U;
    
    // Constants
    FILTER.CONSTANTS={
        SQRT2: Math.SQRT2,
        toRad : Math.PI/180, 
        toDeg : 180/Math.PI
    };
    
    //
    //
    // Abstract Filter
    FILTER.Filter=function() { };
    FILTER.Filter.prototype={
        apply : function(image) { /* do nothing here, override */ }
    };
    
    //
    //
    // Composite Filter Stack
    FILTER.CompositeFilter=function(filters) 
    { 
        this._stack=(typeof filters!='undefined' && filters.length) ? filters : [];
    };
    
    FILTER.CompositeFilter.prototype={
        _stack : [],
        
        apply : function(image) {
            
            if (!this._stack.length) return;
            
            var im=image.getData(), w=image.width, h=image.height, 
                _filterstack=this._stack, _stacklength=_filterstack.length, fi=0, filter;
                
            while (fi<_stacklength)
            {
                filter=_filterstack[fi++]; 
                if (filter) im=filter._apply(im, w, h);
            }
            image.setData(im);
        },
        
        filters : function(f) {
            if (f) this._stack=f;
            return this;
        },
        
        push : function(filter) {
            this._stack.push(filter);
            return this;
        },
        
        pop : function() {
            return this._stack.pop();
        },
        
        remove : function(filter) {
            var i=this._stack.length;
            while (--i>=0) { if (filter===this._stack[i]) this._stack.splice(i,1); }
            return this;
        }
    };
    
    var _canvas=null, _ctx=null;
    
    // static methods
    FILTER.static={
        createImageData : function(w, h) {
            if (!_canvas)
            {
                _canvas=document.createElement('canvas');
                _ctx=_canvas.getContext('2d');
            }
            return _ctx.createImageData(w, h);
        }
    };
    
})(FILTER);/**
*
* Color Matrix Filter(s)
* matrix is 4x5 array of values which are (eg for row 1: Red value): 
* New red Value=Multiplier for red value, multiplier for Green value, multiplier for Blue Value, Multiplier for Alpha Value,constant  bias term
* other rows are similar but for new Green, Blue and Alpha values respectively 
*
* @param colorMatrix (Matrix)
* @package FILTER.js
*
**/
(function(FILTER){

    // Constants
    FILTER.LUMA={
        R : 0.212671,
        G : 0.71516,
        B : 0.072169
    };
    
    
    var 
        // Color Matrix
        CM=FILTER.Array32F,
        toRad=FILTER.CONSTANTS.toRad, toDeg=FILTER.CONSTANTS.toDeg
    ;
    
     function eye()
     {
        return new CM([
                1,0,0,0,0,
                0,1,0,0,0,
                0,0,1,0,0,
                0,0,0,1,0
            ]);
     }
     
     // concatenate 2 Color Matrices (kind of Color Matrix multiplication)
     function CMconcat(tm, mat) 
     {
        var t=new CM(20), m0, m1, m2, m3, m4;
        
        // unroll the loop completely
        // i=0
        m0=mat[0]; m1=mat[1]; m2=mat[2]; m3=mat[3]; m4=mat[4];
        t[ 0 ] = m0*tm[0] + m1*tm[5] + m2*tm[10] + m3*tm[15];
        t[ 1 ] = m0*tm[1] + m1*tm[6] + m2*tm[11] + m3*tm[16];
        t[ 2 ] = m0*tm[2] + m1*tm[7] + m2*tm[12] + m3*tm[17];
        t[ 3 ] = m0*tm[3] + m1*tm[8] + m2*tm[13] + m3*tm[18];
        t[ 4 ] = m0*tm[4] + m1*tm[9] + m2*tm[14] + m3*tm[19] + m4;

        // i=5
        m0=mat[5]; m1=mat[6]; m2=mat[7]; m3=mat[8]; m4=mat[9];
        t[ 5 ] = m0*tm[0] + m1*tm[5] + m2*tm[10] + m3*tm[15];
        t[ 6 ] = m0*tm[1] + m1*tm[6] + m2*tm[11] + m3*tm[16];
        t[ 7 ] = m0*tm[2] + m1*tm[7] + m2*tm[12] + m3*tm[17];
        t[ 8 ] = m0*tm[3] + m1*tm[8] + m2*tm[13] + m3*tm[18];
        t[ 9 ] = m0*tm[4] + m1*tm[9] + m2*tm[14] + m3*tm[19] + m4;
        
        // i=10
        m0=mat[10]; m1=mat[11]; m2=mat[12]; m3=mat[13]; m4=mat[14];
        t[ 10 ] = m0*tm[0] + m1*tm[5] + m2*tm[10] + m3*tm[15];
        t[ 11 ] = m0*tm[1] + m1*tm[6] + m2*tm[11] + m3*tm[16];
        t[ 12 ] = m0*tm[2] + m1*tm[7] + m2*tm[12] + m3*tm[17];
        t[ 13 ] = m0*tm[3] + m1*tm[8] + m2*tm[13] + m3*tm[18];
        t[ 14 ] = m0*tm[4] + m1*tm[9] + m2*tm[14] + m3*tm[19] + m4;
        
        // i=15
        m0=mat[15]; m1=mat[16]; m2=mat[17]; m3=mat[18]; m4=mat[19];
        t[ 15 ] = m0*tm[0] + m1*tm[5] + m2*tm[10] + m3*tm[15];
        t[ 16 ] = m0*tm[1] + m1*tm[6] + m2*tm[11] + m3*tm[16];
        t[ 17 ] = m0*tm[2] + m1*tm[7] + m2*tm[12] + m3*tm[17];
        t[ 18 ] = m0*tm[3] + m1*tm[8] + m2*tm[13] + m3*tm[18];
        t[ 19 ] = m0*tm[4] + m1*tm[9] + m2*tm[14] + m3*tm[19] + m4;
        
        return t;
    }
   
    function CMblend(m1, m2, amount)
    {
        var inv_amount = (1 - amount), i = 0, m=new CM(20);
        while (i < 20) { m[i] = (inv_amount * m1[i]) + (amount * m2[i]);  i++; };
        return m;
    }
    
    FILTER.ColorMatrixFilter=function(matrix)
    {
        if (typeof matrix != 'undefined' && matrix.length)
        {
            this.matrix=new CM(matrix);
        }    
        else
        {
            // identity matrix
            this.matrix=null;
        }
    };
    
    FILTER.ColorMatrixFilter.prototype={
    
        desaturate : function() {
            return this.concat([
                        FILTER.LUMA.R, FILTER.LUMA.G, FILTER.LUMA.B, 0, 0, 
                        FILTER.LUMA.R, FILTER.LUMA.G, FILTER.LUMA.B, 0, 0, 
                        FILTER.LUMA.R, FILTER.LUMA.G, FILTER.LUMA.B, 0, 0, 
                        0, 0, 0, 1, 0
                    ]);
        },
        
        // aliases
        grayscale : function() { return this.desaturate(); },
        
        colorize : function(rgb, amount) {
            var r, g, b, inv_amount;
            if (typeof amount=='undefined') amount=1;
            r = (((rgb >> 16) & 255) * 0.0039215686274509803921568627451);  // / 255
            g = (((rgb >> 8) & 255) * 0.0039215686274509803921568627451);  // / 255
            b = ((rgb & 255) * 0.0039215686274509803921568627451);  // / 255
            inv_amount = (1 - amount);

            return this.concat([
                        (inv_amount + ((amount * r) * FILTER.LUMA.R)), ((amount * r) * FILTER.LUMA.G), ((amount * r) * FILTER.LUMA.B), 0, 0, 
                        ((amount * g) * FILTER.LUMA.R), (inv_amount + ((amount * g) * FILTER.LUMA.G)), ((amount * g) * FILTER.LUMA.B), 0, 0, 
                        ((amount * b) * FILTER.LUMA.R), ((amount * b) * FILTER.LUMA.G), (inv_amount + ((amount * b) * FILTER.LUMA.B)), 0, 0, 
                            0, 0, 0, 1, 0
                        ]);
        },
        
        invert : function() {
            return this.concat([
                        -1 ,  0,  0, 0, 255,
                        0 , -1,  0, 0, 255,
                        0 ,  0, -1, 0, 255,
                        0,   0,  0, 1,   0
                    ]);
        },
        
        saturate : function( s ) {
            var sInv, irlum, iglum, iblum;
            sInv = (1 - s);  irlum = (sInv * FILTER.LUMA.R);
            iglum = (sInv * FILTER.LUMA.G);  iblum = (sInv * FILTER.LUMA.B);
            
            return this.concat([
                    (irlum + s), iglum, iblum, 0, 0, 
                    irlum, (iglum + s), iblum, 0, 0, 
                    irlum, iglum, (iblum + s), 0, 0, 
                    0, 0, 0, 1, 0
                ]);
        },
        
        contrast : function(r, g, b) {
            if (typeof g == 'undefined')  g=r;
            if (typeof b == 'undefined')  b=r;
            r += 1; g += 1; b += 1;
            
            return this.concat([
                    r, 0, 0, 0, (128 * (1 - r)), 
                    0, g, 0, 0, (128 * (1 - g)), 
                    0, 0, b, 0, (128 * (1 - b)), 
                    0, 0, 0, 1, 0
                ]);
        },
        
        brightness : function(r, g, b) {
            if (typeof g == 'undefined')  g=r;
            if (typeof b == 'undefined')  b=r;
            
            return this.concat([
                    1, 0, 0, 0, r, 
                    0, 1, 0, 0, g, 
                    0, 0, 1, 0, b, 
                    0, 0, 0, 1, 0
                ]);
        },
        
        adjustHue : function( degrees ) {
            degrees *=toRad;
            var cos = Math.cos(degrees), sin = Math.sin(degrees);
            
            return this.concat([
                    ((FILTER.LUMA.R + (cos * (1 - FILTER.LUMA.R))) + (sin * -(FILTER.LUMA.R))), ((FILTER.LUMA.G + (cos * -(FILTER.LUMA.G))) + (sin * -(FILTER.LUMA.G))), ((FILTER.LUMA.B + (cos * -(FILTER.LUMA.B))) + (sin * (1 - FILTER.LUMA.B))), 0, 0, 
                    ((FILTER.LUMA.R + (cos * -(FILTER.LUMA.R))) + (sin * 0.143)), ((FILTER.LUMA.G + (cos * (1 - FILTER.LUMA.G))) + (sin * 0.14)), ((FILTER.LUMA.B + (cos * -(FILTER.LUMA.B))) + (sin * -0.283)), 0, 0, 
                    ((FILTER.LUMA.R + (cos * -(FILTER.LUMA.R))) + (sin * -((1 - FILTER.LUMA.R)))), ((FILTER.LUMA.G + (cos * -(FILTER.LUMA.G))) + (sin * FILTER.LUMA.G)), ((FILTER.LUMA.B + (cos * (1 - FILTER.LUMA.B))) + (sin * FILTER.LUMA.B)), 0, 0, 
                    0, 0, 0, 1, 0
                ]);
        },
        
        average : function( r, g, b ) {
            if (typeof r == 'undefined') r=0.3333;
            if (typeof g == 'undefined') g=0.3333;
            if (typeof b == 'undefined') b=0.3334;
            
            return this.concat([
                    r, g, b, 0, 0, 
                    r, g, b, 0, 0, 
                    r, g, b, 0, 0, 
                    0, 0, 0, 1, 0
                ]);
        },
        
        quickContrastCorrection : function(contrast) {
            if (typeof contrast == 'undefined') contrast=1.2;
            
            return this.concat([
                contrast, 0, 0, 0, 0, 
                0, contrast, 0, 0, 0, 
                0, 0, contrast, 0, 0, 
                0, 0, 0, 1, 0
                ]);
        },
        
        quickSepia : function(r, g, b) {
            if (typeof r == 'undefined') r=1;
            if (typeof g == 'undefined') g=r;
            if (typeof b == 'undefined') b=r;
            
            return this.concat([
                r*0.5, 0.5, 0.5, 0, 0, 
                0.33, g*0.33, 0.33, 0, 0, 
                0.25, 0.25, b*0.25, 0, 0, 
                0, 0, 0, 1, 0
            ]);
        },
        
        quickSepia2 : function(r, g, b) {
            if (typeof r == 'undefined') r=1;
            if (typeof g == 'undefined') g=r;
            if (typeof b == 'undefined') b=r;
            
            return this.concat([
                r*0.3930000066757202, 0.7689999938011169, 0.1889999955892563, 0, 0, 
                0.3490000069141388, g*0.6859999895095825, 0.1679999977350235, 0, 0, 
                0.2720000147819519, 0.5339999794960022, b*0.1309999972581863, 0, 0, 
                0, 0, 0, 1, 0
            ]);
        },
        
        threshold : function(threshold, factor) {
            if (typeof factor == 'undefined')  factor=256;
            
            return this.concat([
                    (FILTER.LUMA.R * factor), (FILTER.LUMA.G * factor), (FILTER.LUMA.B * factor), 0, (-(factor-1) * threshold), 
                    (FILTER.LUMA.R * factor), (FILTER.LUMA.G * factor), (FILTER.LUMA.B * factor), 0, (-(factor-1) * threshold), 
                    (FILTER.LUMA.R * factor), (FILTER.LUMA.G * factor), (FILTER.LUMA.B * factor), 0, (-(factor-1) * threshold), 
                    0, 0, 0, 1, 0
                ]);
        },
        
        threshold_rgb : function(threshold, factor) {
            if (typeof factor == 'undefined')  factor=256;
            
            return this.concat([
                    factor, 0, 0, 0, (-(factor-1) * threshold), 
                    0, factor, 0, 0, (-(factor-1) * threshold), 
                    0,  0, factor, 0, (-(factor-1) * threshold), 
                    0, 0, 0, 1, 0
                ]);
        },
        
        threshold_alpha : function(threshold, factor) {
            if (typeof threshold == 'undefined')  threshold=0.5;
            if (typeof factor == 'undefined') factor=256;
            
            return this.concat([
                    1, 0, 0, 0, 0, 
                    0, 1, 0, 0, 0, 
                    0, 0, 1, 0, 0, 
                    0, 0, 0, factor, (-factor * threshold)
                ]);
        },
        
        // blend with another filter
        blend : function( filt, amount ) {
            this.matrix=(this.matrix) ? CMblend(this.matrix, filt.matrix, amount) : new CM(filt.matrix);
            return this;
        },
        
        reset : function() {
            this.matrix=null; return this;
        },
        
        concat : function(mat) {
            this.matrix = (this.matrix) ? CMconcat(this.matrix, new CM(mat)) : new CM(mat);
            return this;
        },
        
        // used for internal purposes
        _apply : function(p, w, h) {
            if (!this.matrix)  return p;
            var pl=p.length, m=this.matrix, i=0, t0, t1, t2, t3;
            while (i<pl)
            {
                t0=p[i]; t1=p[i+1]; t2=p[i+2]; t3=p[i+3];
                p[i]    =  m[0]*t0  +  m[1]*t1  +  m[2]*t2  +  m[3]*t3  +  m[4];
                p[i+1]  =  m[5]*t0  +  m[6]*t1  +  m[7]*t2  +  m[8]*t3  +  m[9];
                p[i+2]  =  m[10]*t0 +  m[11]*t1 +  m[12]*t2 +  m[13]*t3 +  m[14];
                p[i+3]  =  m[15]*t0 +  m[16]*t1 +  m[17]*t2 +  m[18]*t3 +  m[19];
                i+=4;
            }
            return p;
        },
        
        apply : function(image) {
            if (!this.matrix) return image;
            return image.setData(this._apply(image.getData(), image.width, image.height));
        }
    };
    
})(FILTER);/**
*
* Convolution Matrix Filter(s)
*
* @param weights (Array)
* @param opaque (Bool)
* @package FILTER.js
*
**/
(function(FILTER){
    
    var 
        // Convolution Matrix
        CM=FILTER.Array32F,
        
        // hardcode usual pascal numbers, used for binomial kernels
        _pascal=[
            [1],
            [1,	1],
            [1,	2,	1],
            [1,	3,	3, 	1],
            [1,	4, 	6, 	4, 	1],
            [1,	5, 	10,	10,	5, 	1],
            [1,	6, 	15,	20,	15,	6, 	1],
            [1,	7, 	21,	35,	35,	21,	7, 	1],
            [1,	8, 	28,	56,	70,	56,	28,	8, 	1]
        ],
        sqrt2=FILTER.CONSTANTS.SQRT2,
        toRad=FILTER.CONSTANTS.toRad, toDeg=FILTER.CONSTANTS.toDeg
    ;
    
    //
    //
    //  Private methods
    
        // crop if needed
        /*sum = (d) ? (2<<d) : 1;
        if (dim && row.length>dim)
        {
            diff=(row.length-dim); off=diff>>1; il=row.length;
            for (i=0; i<off; i++) { sum-=row[i]; sum-=row[il-1-i]; }
            if (diff%2) sum-=row[off];
            row=row.slice(off, dim+off);
        }*/
    /*
    Another way to generate pascal's numbers is to look at
    1
    1 2 1
    1 3 3 1
    1 4 6 4 1
    Look at the 4 and the 6. It is clear that
    4 = 1 + 3
    6 = 3+3
    pascal(row, col) = pascal(row-1, col-1) + pascal(row-1, col)
    */
    
    // pascal numbers (binomial coefficients) are used to get coefficients for filters that resemble gaussian distributions
    // eg Sobel, Canny, gradients etc..
    function binomialKernel(d) 
    {
        var l=_pascal.length, row, uprow;
        d--;
        if (d<l)
        {
            row=_pascal[d].slice();
        }
        else
        {
            // else compute them iteratively
            row=new CM(_pascal[l-1]);
            while (l<=d)
            {
                uprow=row.slice(); row=[1];
                for (i=0, il=uprow.length-1; i<il; i++) { row.push(uprow[i]+uprow[i+1]); }
                row.push(1);
                if (l<12) _pascal.push(row.slice()); // save it for future dynamically
                l++;
            }
        }
        return row;
    }
    
    function identityKernel(d)
    {
        var i, center=d>>1+1, fact=-f, ker=new Array(d);
        for (i=0; i<d; i++) { ker[i]=0; }
        ker[center]=1;
        return ker;
    }

    function averageKernel(d)
    {
        var i, ker=new Array(d);
        for (i=0; i<d; i++) ker[i]=1;
        return ker;
    }
    
    function derivativeKernel(d)
    {
        var i, f=d>>1, fact=-f, ker=new Array(d);
        for (i=0; i<d; i++) { ker[i]=fact; fact++;  }
        return ker;
    }
    
    function convolveKernels(k1, k2)
    {
        var i, j, kl=k1.length, k, ker=[], sum=0;
        if (typeof (k1[0].length)=='undefined') // simple kernels
        {
            for (i=0; i<kl; i++)
            {
                for (j=0; j<kl; j++) { k=k1[i]*k2[j];  sum+=k;  ker.push(k); }
            }
        }
        else // recursive kernels
        {
            for (i=0; i<kl; i++)
            {
                for (j=0; j<kl; j++) { k=convolveKernels(k1[i], k2[j]);  sum+=k.sum;  ker=ker.concat(k.ker); }
            }
        }
        return {kernel:ker, sum:sum};
    }
    
    function gaussFilter(d)
    {
        var binomial=binomialKernel(d);
        // convolve with itself
        return convolveKernels(binomial, binomial);
    }
    
    function sobelFilter(d, dir)
    {
        var binomial=binomialKernel(d), derivative=derivativeKernel(d);
        if (1==dir) // y
        {
            // convolve them
            return convolveKernels(derivative.reverse(), binomial);
        }
        else
        {
            // convolve them
            return convolveKernels(binomial, derivative);
        }
    }
    
    function prewittFilter(d, dir)
    {
        var average=averageKernel(d), derivative=derivativeKernel(d);
        if (1==dir) // y
        {
            // convolve them
            return convolveKernels(derivative.reverse(), average);
            
            /*if (3==d)
            {
                return { kernel:[1, sqrt2, 1, 0, 0, 0, -1, -sqrt2, -1], sum: 0 };
            }*/
        }
        else // x
        {
            // convolve them
            return convolveKernels(average, derivative);
            
            /*if (3==d)
            {
                return { kernel: [-1, 0, 1, -sqrt2, 0, sqrt2, 1, 0, 1], sum: 0 };
            }*/
        }
    }
    
    function addMatrix(m1, m2)
    {
        var l= m1.length, i, m=new CM(m1.length);
        for (i=0; i<l; i++) m[i]=m1[i] + m2[i];
        return m;
    }
    
    function subtractMatrix(m1, m2)
    {
        var l= m1.length, i, m=new CM(m1.length);
        for (i=0; i<l; i++) m[i]=m1[i]-m2[i];
        return m;
    }
    
    function multiplyScalar(m1, s)
    {
        if (1==s) return new CM(m1);
        var l= m1.length, i, m=new CM(m1.length);
        for (i=0; i<l; i++) m[i]=m1[i]*s;
        return m;
    }
    
    function blendMatrix(m1, m2, a, b)
    {
        var l= m1.length, i, m=new CM(m1.length);
        a=a||1; b=b||1;
        for (i=0; i<l; i++) m[i]=a*m1[i] + b*m2[i];
        return m;
    }
    
    function multiplyMatrix(m1, m2, d) 
    {
        var i, j, k, m=new CM(m1.length), sum, id=0, jd=0, kd=0;
        for (i=0; i<d; i++)
        {
            //jd=0;
            for (j=0; j<d; j++)
            {
                sum=0; kd=0;
                for (k=0; k<d; k++) { sum+=m1[id + k]*m2[kd + j]; kd+=d; }
                m[id + j]=sum; //jd+=d;
            }
            id+=d;
        }
        return m;
    }
    
    function unit(d) 
    { 
        d=(0==d%2) ? d+1 : d;
        var l=d*d, i, center=(l>>2)+1, e=new CM(l);
        for (i=0; i<l; i++) e[i]=0;  e[center]=1;
        return e;
    }
    
    function eye(d) 
    { 
        d=(0==d%2) ? d+1 : d;
        var l=d*d, k, i=0, j=0, e=new CM(l);
        for (k=0; k<l; k++) { if (i==j) e[k]=1; else e[k]=0; j++; if (d==j) { i++; j=0; } }
        return e;
    }
    
    function ones(d, f) 
    { 
        f=f||1;
        var l=d*d, i, o=new CM(l);
        for (i=0; i<l; i++) o[i]=f;
        return o;
    }
    
    //
    //
    //  Simple Convolution Filter
    FILTER.ConvolutionMatrixFilter=function(weights, factor)
    {
        this.factor=factor||1;
        
        if (typeof weights != 'undefined' && weights.length)
        {
            this.matrix=new CM(weights);
            this.dim = ~~(Math.sqrt(weights.length)+0.5);
        }
        else 
        {
            this.matrix=null;
            this.dim = 0;
        }
        this.auxMatrix=null; this._isGrad=false;
    };
    
    FILTER.ConvolutionMatrixFilter.prototype={
        
        // generic low-pass filter
        lowPass : function(d) {
            d=(typeof d == 'undefined') ? 3 : ((d%2) ? d : d+1);
            return this.set(ones(d), 1/(d*d), d);
        },

        // generic high-pass filter (I-LP)
        highPass : function(d, f) {
            d=(typeof d == 'undefined') ? 3 : ((d%2) ? d : d+1);
            f=(typeof f == 'undefined') ? 1 : f;
            // HighPass Filter = I - (respective)LowPass Filter
            var size=d*d, fact=-f/size, w=ones(d, fact), i;
            w[size>>1 +1]=1+fact;
            return this.set(w, 1, d);
        },

        // aliases
        boxBlur : function(d) { return this.lowPass(d); },
        
        // generic binomial(gaussian) low-pass filter
        binomialLowPass : function(d) {
            d=(typeof d == 'undefined') ? 3 : ((d%2) ? d : d+1);
            var filt=gaussFilter(d);
            return this.set(new CM(filt.kernel), 1/filt.sum, d); 
        },

        // generic binomial(gaussian) high-pass filter
        binomialHighPass : function(d) {
            d=(typeof d == 'undefined') ? 3 : ((d%2) ? d : d+1);
            var filt=gaussFilter(d);
            // HighPass Filter = I - (respective)LowPass Filter
            return this.set(blendMatrix(ones(d), new CM(filt.kernel), 1, -1/filt.sum), 1, d); 
        },
        
        // aliases
        gaussBlur : function(d) { return this.binomialLowPass(d); },
        
        sharpen : function(d, f) { 
            f=(typeof f == 'undefined') ? 0.5 : f;  
            if (f<=0)
                return this.set([
                    0, -2, 0, 
                    -2, 10, -2, 
                    0, -2, 0
                ], 0.5, 3);
            else
                return this.highPass(d, f); 
        },
        
        // X-gradient, partial X-derivative (Prewitt)
        prewittX : function(d) {
            d=(typeof d == 'undefined') ? 3 : ((d%2) ? d : d+1);
            var filt=prewittFilter(d, 0);
            return this.set(new CM(filt.kernel), 1, d);
        },
        
        // Y-gradient, partial Y-derivative (Prewitt)
        prewittY : function(d) {
            d=(typeof d == 'undefined') ? 3 : ((d%2) ? d : d+1);
            var filt=prewittFilter(d, 1);
            return this.set(new CM(filt.kernel), 1, d);
        },
        
        // directional gradient (Prewitt)
        prewittDirectional : function(d, theta) {
            d=(typeof d == 'undefined') ? 3 : ((d%2) ? d : d+1);
            theta*=toRad;
            var c=Math.cos(theta), s=Math.sin(theta),
                gradx=prewittFilter(d, 0), grady=prewittFilter(d, 1);
            return this.set(blendMatrix(new CM(gradx.kernel), new CM(grady.kernel), c, s), 1, d);
            /*return this.set([
                    -c+s,   s,   c+s,
                    -c,  0,   s,
                   -c-s,   -s,  c-s
               ], 1, 3);*/
        },
        
        // gradient magnitude (Prewitt)
        prewitt : function(d) {
            d=(typeof d == 'undefined') ? 3 : ((d%2) ? d : d+1);
            var gradx=prewittFilter(d, 0), grady=prewittFilter(d, 1);
            this.set(new CM(gradx.kernel), 1, d);
            this._isGrad=true;
            this.auxMatrix=new CM(grady.kernel);
            return this;
        },
        
        //aliases
        gradX : function(d) { return this.prewittX(d); },
        
        gradY : function(d) { return this.prewittY(d); },
        
        gradDirectional : function(d, theta) { return this.prewittDirectional(d, theta); },
        
        grad : function(d) { return this.prewitt(d); },
        
        // partial X-derivative (Sobel)
        sobelX : function(d) {
            d=(typeof d == 'undefined') ? 3 : ((d%2) ? d : d+1);
            var filt=sobelFilter(d, 0);
            return this.set(new CM(filt.kernel), 1, d);
        },
        
        // partial Y-derivative (Sobel)
        sobelY : function(d) {
            d=(typeof d == 'undefined') ? 3 : ((d%2) ? d : d+1);
            var filt=sobelFilter(d, 1);
            return this.set(new CM(filt.kernel), 1, d);
        },
        
        // directional gradient (Sobel)
        sobelDirectional : function(d, theta) {
            d=(typeof d == 'undefined') ? 3 : ((d%2) ? d : d+1);
            theta*=toRad;
            var c=Math.cos(theta), s=Math.sin(theta),
                gradx=sobelFilter(d, 0), grady=sobelFilter(d, 1);
            return this.set(blendMatrix(new CM(gradx.kernel), new CM(grady.kernel), c, s), 1, d);
        },
        
        // gradient magnitude (Sobel)
        sobel : function(d) {
            d=(typeof d == 'undefined') ? 3 : ((d%2) ? d : d+1);
            var gradx=sobelFilter(d, 0), grady=sobelFilter(d, 1);
            this.set(new CM(gradx.kernel), 1, d);
            this.auxMatrix=new CM(grady.kernel);
            this._isGrad=true;
            return this;
        },
        
        laplace : function(d) {
            return this.set([
                    0,   -1,   0,
                    -1,  4,   -1,
                    0,   -1,   0
                ], 1, 3);
        },
        
        emboss : function(direction, magnitude) {
            direction=(typeof direction == 'undefined' || (direction!=1 && direction!=-1)) ? 1 : direction;
            //magnitude=(typeof magnitude == 'undefined' || magnitude<=0) ? 1 : magnitude;
            magnitude=1;
            var d=1/*1/magnitude*/, f=direction*magnitude; 
            return this.set([
                    -f*2,   -f*1,   0,
                    -f*1,  magnitude*1,   f*1,
                    0,   f*1,   f*2
                 ], d, 3);
        },
        
        // aliases
        embossHigh : function() { return this.emboss(1); },
        
        embossLow : function() { return this.emboss(-1); },
        
        /*bluremboss : function() {
            this.matrix=multiplyMatrix(new CM([
                    1/9,   1/9,   1/9,
                    1/9,  1/9,   1/9,
                    1/9,   1/9,   1/9
                 ]), new CM([
                    -2,   -1,   0,
                    -1,  1,   1,
                    0,   1,   2
                 ]), 3);
             this.dim=3; return this;
        },*/
        
        edges : function(d) {
            return this.set([
                    0,   1,   0,
                    1,  -4,   1,
                    0,   1,   0
                 ], 1, 3);
        },
        
        edges2 : function(d) {
            return this.set([
                    0, 2, 0, 
                    2, -8, 2, 
                    0, 2, 0
                 ], 0.5, 3);
        },
        
        motionblur : function(dir) {
            var w=1, i,j, wm=new CM(
                        0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0
                         );
            if (dir==0)
            {
                for (i=0;i<9;i++)
                {
                    wm[4*9+i]=w;
                }
            }
            else if (dir==2)
            {
                for (i=0;i<9;i++)
                {
                    wm[9*i+5]=w;
                }
            }
            else if (dir==1)
            {
                for (i=0;i<9;i++)
                {
                    wm[9*i+i]=w;
                }
            }
            return this.set(wm, 1/9, 9);
        },
        
        reset : function() {
            this.matrix=null; this.auxMatrix=null; this.dim=0; return this;
        },
        
        set : function(m, f, d) {
            // matrices/kernels need to be convolved -> larger kernel->tensor
            //this.matrix=multiplyMatrix(this.matrix, new CM(m), d);
            this.matrix=new CM(m); this.factor=f; this.dim=d; 
            this.auxMatrix=null; this._isGrad=false;
            return this;
        },
        
        // used for internal purposes
        _apply : function(src, w, h) {
            
            if (!this.matrix) return src;
            
            var side = this.dim, halfSide = side>>1,
                dst=new FILTER.ImArray(src.length),
                // pad output by the convolution matrix
                sw = w, sh = h,
                // go through the destination image pixels
                //alphaFac = this.opaque ? 1 : 0,
                x, y, sx, sy, dstOff, r=0, g=0, b=0, a=0, r1=0, g1=0, b1=0, a1=0, cx, cy, scx, scy,
                srcOff, wt, wt2, ty, yh, scyw, syw, Abs=Math.abs
                ;
            
            yh=0;
            for (y=0; y<h; y++) 
            {
                for (x=0; x<w; x++) 
                {
                    sy = y; sx = x;  dstOff = (yh+x)<<2;
                    // calculate the weighed sum of the source image pixels that
                    // fall under the convolution matrix
                    r=0; g=0; b=0; a=0; ty=0;
                    r1=0; g1=0; b1=0; a1=0;
                    for (cy=0; cy<side; cy++) 
                    {
                        scy = sy + cy - halfSide;
                        if (scy >= 0 && scy < sh)
                        {
                            scyw=scy*sw;
                            for (cx=0; cx<side; cx++) 
                            {
                                scx = sx + cx - halfSide;
                                if (scx >= 0 && scx < sw) 
                                {
                                    srcOff = (scyw + scx)<<2; wt = this.matrix[ty + cx];
                                    r += src[srcOff] * wt; g += src[srcOff+1] * wt;
                                    b += src[srcOff+2] * wt; /*a += src[srcOff+3] * wt;*/
                                    if (this.auxMatrix)
                                    {
                                        wt2 = this.auxMatrix[ty + cx];
                                        r1 += src[srcOff] * wt2; g1 += src[srcOff+1] * wt2;
                                        b1 += src[srcOff+2] * wt2; /*a += src[srcOff+3] * wt;*/
                                    }
                                }
                            }
                        }
                        ty+=side;
                    }
                    if (this._isGrad)
                    {
                        dst[dstOff] = this.factor*(Abs(r)+Abs(r1));  dst[dstOff+1] = this.factor*(Abs(g)+Abs(g1));
                        dst[dstOff+2] = this.factor*(Abs(b)+Abs(b1));  /*dst[dstOff+3] = this.factor*(a + alphaFac*(255-a));*/
                    }
                    else
                    {
                        dst[dstOff] = this.factor*r;  dst[dstOff+1] = this.factor*g;
                        dst[dstOff+2] = this.factor*b;  /*dst[dstOff+3] = this.factor*(a + alphaFac*(255-a));*/
                    }
                    dst[dstOff+3] = src[dstOff+3];
                }
                yh+=w;
            }
            return dst;
        },
        
        apply : function(image) {
            if (!this.matrix) return image;
            return image.setData(this._apply(image.getData(), image.width, image.height));
        }
    };
    
})(FILTER);/**
*
* Displacement Map Filter
* accepts an image as displace map
* displaces/distorts the target image according to displace map
*
* @param displaceMap (Image)
* @package FILTER.js
*
**/
(function(FILTER){
    
    // Constants
    FILTER.CHANNEL={
        RED : 0,
        GREEN : 1,
        BLUE : 2,
        ALPHA : 3
    };
    FILTER.MODE={
        IGNORE : 0,
        WRAP : 1,
        CLAMP : 2,
        COLOR : 4
    };

    var 
        Min=Math.min, Max=Math.max
    ;
    
    FILTER.DisplacementMapFilter=function(displacemap)
    {
        this.scaleX=1;
        this.scaleY=1;
        this.startX=0;
        this.startY=0;
        this.componentX=0;
        this.componentY=0;
        this.color=0;
        this.mode=FILTER.MODE.CLAMP;
        this.map=displacemap;
    };

    FILTER.DisplacementMapFilter.prototype={
    
        // used for internal purposes
        _apply : function(im, w, h) {
            
            if (!this.map) return im;
            
            var map=this.map.getData(), mw = this.map.width, mh = this.map.height, ww=Min(mw, w), hh=Min(mh, h),
                sx=this.scaleX*0.00390625 /* /256 */, sy=this.scaleY*0.00390625, /* /256 */
                alpha=(this.color >> 24) & 255, red=(this.color >> 16) & 255,
                green=(this.color >> 8) & 255, blue=this.color & 255,
                sty=~~(this.startY), stx=~~(this.startX),
                comx=this.componentX, comy=this.componentY, mode=this.mode,
                xx,yy,dstoff,mapoff,srcy,srcx,dispoff,x,y,ymw, yyw, styw=sty*w, stymw=sty*mw,
                // create new image for copy manipulations
                dst=new FILTER.ImArray(im.length)
                ;

            // apply filter
            ymw=0; yyw=styw;
            for (y=0; y<hh; y++) 
            {
                yy=y+sty;
                if (yy>=0 && yy<h)
                {
                    for (x=0; x<ww; x++) 
                    {
                        xx=x+stx;
                        if (xx<0 || xx>=w) continue;
                        
                        dstoff = (yyw+xx)<<2;  mapoff = (ymw+x)<<2;
                        srcy = yy + ~~((map[mapoff+comy]-128)*sy);
                        srcx = xx + ~~((map[mapoff+comx]-128)*sx);

                        if (srcy>=h || srcy<0 || srcx>=w || srcx<0)
                        {
                            switch(mode)
                            {
                                case FILTER.MODE.IGNORE: 
                                    continue;  break;
                                
                                case FILTER.MODE.COLOR:
                                    dst[dstoff]=red;  dst[dstoff+1]=green;
                                    dst[dstoff+2]=blue;  dst[dstoff+3]=alpha;
                                    continue;  break;
                                    
                                case FILTER.MODE.WRAP:
                                    if (srcy>=h) srcy-=h;
                                    if (srcy<0) srcy+=h;
                                    if (srcx>=w) srcx-=w;
                                    if (srcx<0)  srcx+=w;
                                    break;
                                    
                                case FILTER.MODE.CLAMP:
                                default:
                                    if (srcy>=h)  srcy=h-1;
                                    if (srcy<0) srcy=0;
                                    if (srcx>=w) srcx=w-1;
                                    if (srcx<0) srcx=0;
                                    break;
                            }
                        }
                        dispoff=(srcy*w + srcx)<<2;

                        // new pixel values
                        dst[dstoff]=im[dispoff];
                        dst[dstoff+1]=im[dispoff+1];
                        dst[dstoff+2]=im[dispoff+2];
                        dst[dstoff+3]=im[dispoff+3];
                        (x==y) && console.log(dstoff, dispoff);
                    }
                }
                ymw+=mw; yyw+=styw;
            }
            return dst;
        },
        
        apply : function(image) {
            if (!this.map) return image;
            return image.setData(this._apply(image.getData(), image.width, image.height));
        }
    };
    
})(FILTER);/**
*
* Non-Linear Filter(s)
*
* @package FILTER.js
*
**/
(function(FILTER){
    
    //
    //
    //  Non-Linear Filter
    FILTER.NonLinearFilter=function(func)
    {
        this.func=func;
        this.isMedian=false;
        this.isMinimum=false;
        this.isMaximum=false;
        this.dim=0;
    };
    
    FILTER.NonLinearFilter.prototype={
        
        median : function(d) { 
            d=(typeof d == 'undefined') ? 3 : ((d%2) ? d : d+1);
            this.isMedian=true; this.isMinimum=false; this.isMaximum=false; this.dim=d; return this; 
        },
        
        erode : function(d) { 
            d=(typeof d == 'undefined') ? 3 : ((d%2) ? d : d+1);
            this.isMedian=false; this.isMinimum=true; this.isMaximum=false; this.dim=d; return this; 
        },
        
        dilate : function(d) { 
            d=(typeof d == 'undefined') ? 3 : ((d%2) ? d : d+1);
            this.isMedian=false; this.isMinimum=false; this.isMaximum=true; this.dim=d; return this; 
        },
        
        // used for internal purposes
        _apply : function(src, sw, sh) {
            
            if (this.isMedian)
            {
                var side = this.dim, halfSide = side>>1, len=side*side,
                    dst=new FILTER.ImArray(src.length),
                    // pad output by the convolution matrix
                    w = sw, h = sh,
                    x, y, sx, sy, dstOff, r=[], g=[], b=[], a, cx, cy, scx, scy,
                    srcOff, wt, ty, yh, scyw, t
                    ;
                
                yh=0;
                for (y=0; y<h; y++) 
                {
                    for (x=0; x<w; x++) 
                    {
                        sy = y; sx = x;  dstOff = (yh+x)<<2;
                        // calculate the weighed sum of the source image pixels that
                        // fall under the convolution matrix
                        r.length=0; g.length=0; b.length=0; ty=0;
                        for (cy=0; cy<side; cy++) 
                        {
                            scy = sy + cy - halfSide;
                            if (scy >= 0 && scy < sh)
                            {
                                scyw=scy*sw;
                                for (cx=0; cx<side; cx++) 
                                {
                                    scx = sx + cx - halfSide;
                                    if (scx >= 0 && scx < sw) 
                                    {
                                        srcOff = (scyw + scx)<<2;
                                        r.push(src[srcOff]); g.push(src[srcOff+1]); b.push(src[srcOff+2]);
                                    }
                                }
                            }
                            ty+=side;
                        }
                        // take the median
                        r.sort(); g.sort(); b.sort();
                        if (r.length%2==1) // odd, take median
                        {
                            t=~~(0.5*r.length)+1;
                            dst[dstOff] = r[t];  dst[dstOff+1] = g[t];
                            dst[dstOff+2] = b[t];
                        }
                        else // even, take average
                        {
                            t=~~(0.5*r.length);
                            dst[dstOff] = ~~(0.5*(r[t]+r[t+1]));  dst[dstOff+1] = ~~(0.5*(g[t]+g[t+1]));
                            dst[dstOff+2] = ~~(0.5*(b[t]+b[t+1]));
                        }
                        dst[dstOff+3] = src[dstOff+3];
                    }
                    yh+=w;
                }
                return dst;
            }
            else
            {
                var side = this.dim, halfSide = side>>1, len=side*side,
                    dst=new FILTER.ImArray(src.length),
                    // pad output by the convolution matrix
                    w = sw, h = sh,
                    x, y, sx, sy, dstOff, r, g, b, a, cx, cy, scx, scy,
                    srcOff, wt, ty, yh, scyw, t
                    ;
                
                yh=0;
                for (y=0; y<h; y++) 
                {
                    for (x=0; x<w; x++) 
                    {
                        sy = y; sx = x;  dstOff = (yh+x)<<2;
                        // calculate the weighed sum of the source image pixels that
                        // fall under the convolution matrix
                        if (this.isMaximum)
                        {
                            r=0; g=0; b=0;
                        }
                        else if (this.isMinimum)
                        {
                            r=255; g=255; b=255;
                        }
                        ty=0;
                        for (cy=0; cy<side; cy++) 
                        {
                            scy = sy + cy - halfSide;
                            if (scy >= 0 && scy < sh)
                            {
                                scyw=scy*sw;
                                for (cx=0; cx<side; cx++) 
                                {
                                    scx = sx + cx - halfSide;
                                    if (scx >= 0 && scx < sw) 
                                    {
                                        srcOff = (scyw + scx)<<2;
                                        if (this.isMaximum)
                                        {
                                            if (src[srcOff]>r) r=src[srcOff];
                                            if (src[srcOff+1]>g) g=src[srcOff+1];
                                            if (src[srcOff+2]>b) b=src[srcOff+2];
                                        }
                                        else if (this.isMaximum)
                                        {
                                            if (src[srcOff]<r) r=src[srcOff];
                                            if (src[srcOff+1]<g) g=src[srcOff+1];
                                            if (src[srcOff+2]<b) b=src[srcOff+2];
                                        }
                                    }
                                }
                            }
                            ty+=side;
                        }
                        dst[dstOff] = r;  dst[dstOff+1] = g;
                        dst[dstOff+2] = b;
                        dst[dstOff+3] = src[dstOff+3];
                    }
                    yh+=w;
                }
                return dst;
            }
            return src;
        },
        
        apply : function(image) {
            return image.setData(this._apply(image.getData(), image.width, image.height));
        }
    };
    
})(FILTER);